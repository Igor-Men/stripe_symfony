# Testing Webhooks

The reason that web hooks are so hard is that they're kind of impossible to test. Especially with payment stuff. There's no way for me to simulate on stripe a real subscription deleted event, and then have it actually communicate locally to my local copy, to see if my code works. Actually that's not entirely true. In this part, I'm going to show you a couple of strategies on how you can test you web hooks and make sure they're air tight. I do not want to mess up something when cancellations or renewals happen.

The first strategy is going to be this, we're going to create an automated test that actually sends a fake web hook up to our controller, so that we can check to see if it's handled correctly. There's going to be a couple complications with this that we'll work through. First, in your terminal, make sure that your project has PHP unit installed, by running composer require phpunit/phpunit --dev. While that's running, you should have a tutorials directory in you tutorial, with a web hook controller task. I want you to copy that, and I'll put that into the test/app bundle/controller directory.

This is just a little bit of a starting test, in Symphony specifically. The way you're going to test your app if you're Symphony will be slightly different, but fundamentally the same. In this test, we boot Symphony's kernel, because that give us access to the container, so we can use things like the entity manager, and make queries to our database. I also have a private function called Create Subscription. We're not using this yet, but it's going to be a really nice function, because it creates a user in the database, and creates an active subscription for that user, and it saves everything. That will be important so that we can create a subscription, send the web hook for that subscription, and then verify that the subscription is cancelled after the web hook is processed.

Let's start with a public function, test stripe customer subscription deleted method. The first thing we need to do is to create a subscription in the database. I'll say subscription equals this, create subscription. Now we have one in the database. Second, which I'll put as a to do for now, we're going to send cancellation web hook. Then finally, after we do that, we should be able to say, "This assert false, that subscription arrow is active". Make sense?

Now to actually send the fake web hook, we're literally going to need a bunch of JSON that we can send up there. At the bottom of this, I'm actually going to create a new private function called Get Customer Subscription Deleted Event. That takes any subscription ID. What we're going to do here is, we're actually going to copy the real JSON from a real web hook, then I'm going to paste it in here by saying, "$JSON=<<<EOF", just as a way that we can easily post a bunch of data. Then here's the important part. When we read the event data, we read off the data.object.ID, in order to figure out the subscription ID. I'm going to replace this with %S. Then at the bottom of this function, I'm going to return sprint F JSON subscription ID. In other words, if we call this function and pass it a subscription ID in our database, it will create a realistic looking set of JSON, but with that subscription ID as the data object ID. We're faking the JSON.

Now above in our function, we'll say event JSON = this arrow, get customer subscription. Deleted event, we'll pass that subscription arrow, get stripe subscription ID, which is just a fake value that we've created down here.

Second, we're going to create a client object. We'll say this arrow, create client. This is Symphony's internal client that's going to make a web request in our application. You can also, if you want to, use the guzzle HTP client. This is the important part that will be different if you're not in Symphony. But one way or another, you're making a real HTTP request into your application. To do that with this, we're going to cite client arrow request, and then we just need to pass it a whole bunch of arguments.

The first one's the method, so we'll send a post method, because that's what stripe does. Second, we'll say /web hooks, /stripe. Then we just need to pass a couple empty arrays for parameters, files, and server, to get to the content argument. This is the content of the request, and this will be our event JSON.

That should hit our web hook, and just to see what's happening, let's dump client arrow get response arrow get content, in case there's an error, we'll be able to see it a little more easily. Then, as a sanity check, we'll say this assert equals 200 client arrow get response arrow get status code. Because obviously if it's not a 200 status code, it probably didn't work.

To test all of this, I'm going to copy this method name here. Go back to our terminal, looks like PHP unit installed just fine. We'll say that/vendor/bin PHP unit-- filter, and paste that, so it just runs that one test.

Okay, blew up, let's see what's going on here. An exception occurred in driver, unknown database stripe recording_test. I have, in my Symphony project, a different test database set up. You can see it down here, with database_name which is our normal database name, _test. That's a Symphony specific thing that means I need to set up my database as a test environment, which I'll do with BIN console, doctrine:database:create --env=test. Then same thing with doctrine:schema. Create. Then, we can try running our test again.

Okay, another big explosion. Let's go all the way to the top, and check this out. You can see the test actually failed, asserting that 500, a status code, matches 200. So there was a 500 status code, and down here is actually where we're dumping the content of the response. You can see immediately in the title, the problem. No such event evt_00000. What's happening is, the ID of our fake event is evt_0000. That's clearly not a real event. But we set up our web hook controller to read the ID off of this, and then use stripe's API to go fetch this event. We did that to prevent a third party from sending fake events. Well guess what, we now are that third party trying to send fake events. Except we do want it to work.

What we basically want is, in the real world, we do want to use stripe's API to fetch this event object. But in the test environment, we don't want to do this. We want our code just to use the raw body that we're sending up, without verifying to see if that's valid with stripe. To do that, we're going to set a little flag in the test environment only. An app config can fake that YML under parameters. I'm going to create a new parameter called verify stripe event, set that to true. I'm going to copy that, and then in config_test.YML, I'll create a parameters key here, and it will set this to false.

Now, in our web hook controller, we just need an if statement. If this arrow get parameter, verify stripe event is true, then we'll keep a normal behavior that looks it up for the API. Else, we're going to fake the stripe event in the test environment. We'll do that by saying stripe event equals JSON decode request arrow get content.

This is not technically perfect, because this stripe event up here is a stripe event object, and this stripe event down here is actually a standard class object. But both of them allow you to fetch the data off just by using the arrow operator. Unless you use some other specific stripe event object methods, this is a good way to fake it.

With that fixed, let's try our test again. This time, no errors. In fact, you can see our dumped content here looks good, event handled. But failed asserting that true is false on line 43. It looks like our web hook is not working, because the subscription is still active. Actually, this is not entirely true, this is a little thing specific to doctrine. What happens is, the database probably has been updated, but we need to re-query for a fresh subscription object, because this subscription object is out of date. We'll say subscription equals this arrow EM, because I have an entity manager property set up near the top. Then we'll say, "Get repository, app bundle subscription", and then we'll find a new fresh subscription.

Then finally, we'll run that, and it works.

This is my favorite way of testing web hooks. It might get even more complicated later. If your web hook handling logic makes further API requests to stripe, you're also going to need to fake those. I'm going to show you one other way.

Let me just mention two other ways that you can test your web hooks. Probably the most reliable one is to actually use real web hooks. What I mean here is, after you deploy your code to beta, you can actually set up your web hooks to point to your beta server. The only problem with that is waiting for a payment failure to happen over a 30 day period is going to take a really long time to test your API. One thing you can do is, you can temporarily create a new custom plan, and down here under interval, you can actually get down all the way to one day. So at least you can test different situations every day, over about a week period. You can test that the subscription is renewed. You could then update your credit card to a credit card who is going to fail payment, and then wait to see what happens after you fail a payment. It's not perfect, it's slow, but it's a really nice way to go.

Another option is to actually point the web hooks temporarily at your local computer. We can't do that now, because my local machine is not accessible to the internet. But by using a cool utility called Ngrok, you can temporarily set up a URL locally, that's accessible to the entire internet. Let me show you what I mean here. I already have this installed. I'm going to go into my terminal, go into the web directory since that's the document root of our project. I'm going to type ngrok http 8000, because we want to expose port 8000. As soon as we do that, it gives us a cool little URL here.

Let's go back, paste that in, and it won't work initially because it hits this little security check to make sure that we are not accessing the dev environment from outside of our computer. Let's go into the web directory, and just temporarily, I'm going to comment out these two lines down here that prevent outside access to the dev environment. Then when you refresh, everything looks good. This means that we can go to our web hook configuration, add an end point, switch to the test environment, and we're going to have it just send us the one event that we support. Right now, customer.subscription.deleted. Make sure that you have a correct URL set up, which for us is /webhooks/stripe. That's better.

Here's the cool part. In our application right now, we do have an active subscription. If we go to customers, we can see our one customer here, and we can see their current active subscription. The one we have in our database should be this top most recent one. If we go here and cancel that subscription, select it immediately so it actually cancels it and sends the web hook event, that should send the web hook to ngrok, and if we refresh, it should know that our web hook is canceled. It hasn't worked yet, so let's look into what's going on here.

If we go to events and web hooks, you should see one on top, and actually you'll see that this says that it was actually successful. You can even see the response down here that says we handled that. If we refresh now, it actually goes away, so we were just a little fast at first there, but that is your web hook in action. Unfortunately, you can't use that to test all of your web hooks. There are certain things like a payment failing that might be a little bit harder, but that's a really good way to go.
